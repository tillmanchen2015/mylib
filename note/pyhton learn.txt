python
帮助命令help(命令)
字符串: 单引号 双引号 三引号。转义符也是反斜杠。句末的反斜杠表示串联两行的字符串。
逃避字符: r后面跟的字符串将不考虑转义。
unicode字符串: u
字符串连在一块写就是字符串拼接
python没有char
print可以自动加空格区分不同变量！
if没有括号有冒号
python没有switch语句
while可以跟else
for in
range(1,5)不包括5
def定义函数
python使用缩进达到大括号的目的
python使用外部变量用global
通过关键字来给函数赋值
每个函数都有返回值，默认return None
docstring: 文档字符串。在函数体的第一行开始的多行字符串。首字母大写，第二行空白，最后以句号结尾。help抓取的就是文档字符串。
每个模块都有__name__，如果它是__main__
dir()可以打印出当前模块的符号
print后面加逗号可以消除换行符
元组和列表很像，前者不可更改
只有一个元素的元组需要加逗号，很奇葩
字典: 键必须唯一，必须是不可变的对象。
索引可以是负数。-2表示倒数第二个元素。
python的切片是拷贝，go的切片是引用
pycharm
取当前时间 time.strftime
文件存在及创建: os.exist os.create
os.sep: 对于linux是/，win是\,mac是:
一条语句写成多行要加反斜杠
注意构造函数是__init__
python的字符串格式化特别简单
实例变量用self定义，否则就是类变量。
__del__类似析构函数，但是运行时间不定，不必依赖它。
类中的双下划线开头的变量为私有变量，单下划线开头的变量不希望外界访问，但是不强制。
python不会自动调用基类的构造函数，需要子类主动调用。
文件操作file
持久化 cpickle
异常处理 try except  raise
命令行参数 sys.argv
对于变参支持好，*表示元组，**表示字典
字典的key和value都可以混用多钟数据类型
注意，python和go的slice的区别: 前者是拷贝，后者是引用
list[1:]和list[1:-1]是不同的，前者包括最后一个元素，后者不包括
list也是可以多种数据类型混用
注意list append 和extend区别。后者是连接两个list查找:in 和 index，但是后者会抛出异常
list remove只会删除第一个匹配元素！并且会在查找失败时抛出异常！
list 的加号类似于extend，但是前者会返回一个值，后者只做修改。
list乘号不是依次对元素做乘法，而是起到重复器的作用。
tuple没有remove append extend方法，甚至没有indec，只能用in
lust和tuple可以互相转化！
续行符 \
快速赋值 : range 
dictionary的items函数返回由key value组成的tuple的list
join连接字符串list，split是相反操作，把字符串生成list
str用于将整形转成字符串 ，甚至于list module都可以转化。
所有pathon方法都是虚函数
copy模块可以用来拷贝任意类型
继承usrdict需要调用父类的init，继承dict却不要
==内部调用的是__cmp__
len()内部调用的是__len__
java的str1==str2并不是比较字符串内容，而是确定字符串是否指向同一块内存。对此，python字符串内容比较是==，而同一性确认是str1 is str2
类属性和数据属性，类似于类的静态变量和成员变量。类属性既可以通过类来引用，也可以通过类的实例来引用。
python没有常量
私有化: 名字前面加__，但是最后面没有__。后面有__的是专有方法，一般是由python调用。
类似于cat的快速语法:print file("").read()
os.environ是环境变量
sys.module是导入库的字典
每个类可以通过__module__来查询它的模块
路径连接 os.path.join()
用户根目录 os.path.expanduser()
路径划分文件名 os.path.split()
文件名划分格式 os.path.splittext()
glob.glob模块提供了比os.listgdir更强大的功能，支持通配符
正则表达式模块: re
最后匹配 $
最前匹配 ^
边界匹配 \b 由于反斜杠是转义符，所以正则表达式推荐使用r字符串
？匹配0个或者1个前面的字符
{n,m} 匹配最少n最多m个前面的字符
^ 匹配字符串的开始。
• $ 匹配字符串的结尾。
• \b 匹配一个单词的边界。
• \d 匹配任意数字。
• \D 匹配任意非数字字符。
• x? 匹配一个可选的 x 字符 (换言之，它匹配 1 次或者 0 次 x 字符)。
• x* 匹配 0 次或者多次 x 字符。
• x+ 匹配 1 次或者多次 x 字符。
• x{n,m} 匹配 x 字符，至少 n 次，至多 m 次。
• (a|b|c) 要么匹配 a，要么匹配 b，要么匹配 c。
• (x) 一般情况下表示一个记忆组 (remembered group)。你可以利用re.search 函数返回对象的 groups() 函数获取它的值。
字符串格式化的字典形式。
变量作用域: 注意LEGB
星号表达式: 用于将一个列表进行拆组。列表是可以通过多变量赋值被任意拆解的，。
向一个 list 追加 n 个项的代价为 O(n)，而向一个字符串追加 n 个项的代价是 O(n2)。
mmap 内存映射文件
memoryview 生成非拷贝的切片
collection.deque 自动更新的队列。list插入开头是on，队列插入开头是o1
找出N个最大的元素 heapq.nlargest。底层是堆排序。On复杂度。
优先级队列 也可用heapq实现，heapq.heappush()和heappoo()都保证heap[0]最小。时间复杂度都是On
python在比较元组的时候，从第一项开始，如果可以比较，就不再比较后面的项。所以通过加入额外的自增序列或者优先级可以进行排序。
collection.ordereddict 提供了有顺序的dict，但是内存大一倍
对dict进行排序或者求最大值最小值，借助zip()，翻转key value生成元组列表
生成器类似于列表解析，只不过是()而不是[]。生成器并没有把所有元素都读进内存，弱智只能用for in迭代一次！yield可以产生生成器！
消除重复元素，可以直接将列表转为set，但是并不保证顺序。
命名切片: slice[n1,n2]
注意区分python可变对象和不可变对象！大部分都是不可变对象，比如数值类型、字符串类型、元组类型！而列表、字典、集合都是可变对象！
注意区分赋值和切片拷贝！前者没有任何拷贝，完全是相同对象！而切片拷贝是浅拷贝，会简单拷贝元素内部的指针！如果切片的元素是列表或者字典，切片拷贝的操作也会影响源数据！
对于相同的数值、字符串，python只会保存一份拷贝！比如a=10 b=10 那么a和b其实是同一块对象！然而元组不一样。
注意a = a+b和a+=b并不一样！对于不可变对象，前者造成a的对象改变，而后者可能是a本身的扩展！
浅拷贝和深拷贝都是针对容器变量说的。对于字符串、数值，没有拷贝一说。或者说，没有深拷贝，都是类似浅拷贝。
collection.counter计算集合中出现次数最多的元素。
内置sorted进行排序，使用lambda返回排序的key，或者使用attegetter()，后者支持多key排序
排序中的两种getter: attrgetter和itemgetter。前者用来按照class中的属性排序，后者也是按照dict中的key排序。都支持多key排序。
列表推导或者列表解析的问题在于可能产生巨大的结果集，影响内存。替代品是生成器。生成器就是把列表的中括号换成小括号。
字典推导: 类似列表推导，只是括号为{}。因此对于列表和字典，应该优先考虑推导公式而不是for遍历。
collections.ChainMap 合并两个字典成为一个逻辑上的字典。允许两个字典有重复的键，对应操作会忽略第二个。注意，chainmap是引用，原字典的更新会影响合并后的字典。
fnmatch介于简单字符串匹配和强大的正则匹配之间
正则表达式中的?用于将*和+转变为非贪婪模式。
数据可视化 : matplotlib
装饰器: 函数里返回一个函数。新函数装饰了目标函数。
闭包: 内部函数可以捕获上一层封闭代码域的变量，储存在自己的空间内。
高级参数传递: *:位置参数传递  **:字典参数传递