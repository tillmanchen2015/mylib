go
nil相当于null
格式控制任意类型%v
函数可以在声明前被调用
make可以创建引用
一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。
大写字母和小写字母是不同的
如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函
数名本身也是包级名字），那么它将是导出的。
Go语言程序员推荐使用 驼峰式 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔
Go语言主要有四种类型的声明
语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明
在包级别的函数定义可以在使用之后
var 变量名字 类型 = 表达式，注意是先名字后类型
如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。数
组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在
未初始化的变量。
多个变量的初始化var b, f, s = true, 2.3, "four"
简短变量声明，它以“名字:= 表达式”形式声明变量，变量的类型根据表达式来自动推导
i, j = j, i // 交换 i 和 j 的值
指针，类似c，零值nil
flag包，解析命令行参数
var或者new不能说明是分配在栈上还是堆上。
变量的生存期: 从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的。
go语言术语: 逃逸
元祖赋值: 可以同时更新多个变量的值，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。交换变量可以这么写:
x, y = y, x，或者用在接收返回两个值的函数。如果只有需要一个值，并不都需要，我们可以用下划线空白标识符 _ 来丢弃不需要的值。
对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型
许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对
应的String方法返回的结果打印
在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的
定义一个新类型: type
golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包
包的初始化首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始
化 。这个优先解决依赖很有意思，可以先使用，再声明。
如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具
首先会将.go文件根据文件名排序，然后依次调用编译器编译
Unicode字符rune类型是和int32等价的类型，同样byte也是uint8类型的等价类型
最高bit位用作表示符号位，一个n-bit的有符号数的值域是从−2 到2 − 1。无符号整数的所有bit位都用于表示非负数，值域是0到2 − 1
以0开始的八进制格式书写，或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。
fmt.Printf("%d %[1]o %#[1]o\n", o) 这是一个小技巧，只有一个参数，却输出三次
短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不在被求值。
文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列
子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一
个新字符串。
注意: 字符串的值是不可以改变的。这使得赋值操作代价很低。
Unicode标准收集了超过120,000个字符，涵盖超过100多种语言。通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型。将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样的大小32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间，因为大数据计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节能表示。
UTF8编码使用1到4个字节
来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表
示。每个符号编码后第一个字节的高端bit位用于表示总共有多少编码个字节。如果第一个字
节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统
的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit
都以10开头。
0xxxxxxx runes 0-127 (ASCII)
110xxxxx 10xxxxxx 128-2047 (values <128 unused)
go的字符串是utf8编码，可以直接操作中文字符。len()返回字符串的字节数，utf8.RuneCountInString(s)返回的是码点数，utf8.DecodeRuneInString可以解析utf8字符串，更方便的rang自动处理utf8.如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符'\uFFFD'，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的号"𐀢。
注意:str[1:4]是不包括str[4]的！
将一个整数转为字符串，一种方法是fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)：
%T可以打印类型信息
iota生成器，用于常量表达式，类似于枚举
类型常量: 拥有极高的精确度，至少是256位
数组的初始化: symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}
数组的相等: 数组每个元素都相等，不是比较地址
Slice（切片）代表变长的序列，序列中每个元素都有相同的类型
注意slice和数组在初始化时候的不同: slice不需要制定长度，数组一般需要最起码也要三个点
slice不能像数组一样比较大小！
一个零值的slice等于nil。一个nil值的slice并没有底层数组
如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断
make可以创建一个slice, make([]T, len, cap)
copy函数可以拷贝同类型的切片，长度不一样或者有重叠都没关系。
使用append appendInt来更新切片
map是哈希表实现。向一个nil的map插入数据会触发异常。但是访问一个并不存在的key会返回0
unicode.ReplacementChar表示无效的utf编码。
map的key必须是可比较的，字符串可以，但是切片是不可以的。融通的方法是把字符串
奇怪的是结构体指针访问成员变量用的是点操作符
var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (proactive team player)"
如果结构体成员名字是以大写字母开头的，那么该成员就是导出的
如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函
数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。
pp := &Point{1, 2}，这种写法直接得到结构体指针，是由于go的特殊的变量生存期。
匿名成员: 结构体中的结构体成员可以忽略命名。这样在访问叶子时可以跳过匿名成员。不能有两个相同类型的匿名成员。
json数组可以编码go的数组和切片，json对象可以编码map和结构体
将结构体切片转为json的过程叫做编组，marshaling
jason.marshal, jason.unmarshal
高级格式化: 模板。模板提供了对长串的格式化字符串的检查、更强的灵活性。有text/template和html/template
函数返回值可以有形参，叫有名返回值。一般都是无名返回值。
没有函数体的函数说明不是go语言实现
golang.org/x/... 目录下
存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加
密解密、开发者工具提供支持的扩展包。
go语言的栈是动态递增的！
bare return: 一个函数如果返回值全是命名的，那么return就不必带任何值。
内置的error是接口类型，如果error返回none nil类型，那么其他返回值都是未定义的。所以首先要判断error!
函数值叫做闭包
变量的生存期不由它的作用域决定
函数记录的是变量的地址，而非值！所以在for循环中不能用for后面的变量给函数传值，因为它会被改变。有效的作用是用一个局部变量承接for变量。
defer 可以让函数在父函数return更新返回值之后再被调用，多个defer的调用顺序和声明顺序相反。注意循环体，defer可能会导致资源耗尽。异常发生后，defer也会调用。
go语言可以为任意类型添加方法，包括基本类型以及切片。
nil可以作为接收器
os包提供了对文件是否存在的判断。
注意区分: c++的虚基类和go的接口的区别。实现虚基类用到的是继承，go实现接口只需要实现和接口的方法。
箭头操作符 <-  用在channel通信。
已经关闭的channel再次发送会导致异常，然而仍然可以接受数据
无缓存的channel也叫作同步channel
关闭channel后，发送方再次发送会导致异常，接受方会从阻塞中跳出来，收到零值。
goroutine泄露: channel一直阻塞，无法出来。泄露的goroutine无法被垃圾回收，一定要保证goroutine正常退出。
尴尬并行问题: 子问题都是独立的
优雅的关闭channel也是一门艺术。不关闭，channel永远出值。提前关闭又怕goroutine不优雅退出。所以借助sync.waitgroup
